<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VacuumMeshing: src/BoundaryGeneration/boundaryGeneration.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VacuumMeshing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7cc2a0068078ac753f6cc5245d1a42a7.html">BoundaryGeneration</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">boundaryGeneration.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="boundaryGeneration_8hpp_source.html">BoundaryGeneration/boundaryGeneration.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for boundaryGeneration.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="boundaryGeneration_8cpp__incl.png" border="0" usemap="#asrc_2BoundaryGeneration_2boundaryGeneration_8cpp" alt=""/></div>
<map name="asrc_2BoundaryGeneration_2boundaryGeneration_8cpp" id="asrc_2BoundaryGeneration_2boundaryGeneration_8cpp">
<area shape="rect" title=" " alt="" coords="892,5,1079,47"/>
<area shape="rect" href="boundaryGeneration_8hpp.html" title=" " alt="" coords="892,95,1079,136"/>
<area shape="rect" href="removeDupeNodes_8hpp_source.html" title=" " alt="" coords="795,184,973,225"/>
<area shape="rect" title=" " alt="" coords="997,191,1176,218"/>
<area shape="rect" title=" " alt="" coords="861,541,984,568"/>
<area shape="rect" title=" " alt="" coords="3261,541,3387,568"/>
<area shape="rect" title=" " alt="" coords="1009,541,1151,568"/>
<area shape="rect" title=" " alt="" coords="5,541,171,568"/>
<area shape="rect" title=" " alt="" coords="629,541,837,568"/>
<area shape="rect" title=" " alt="" coords="195,541,397,568"/>
<area shape="rect" title=" " alt="" coords="422,541,605,568"/>
<area shape="rect" href="surfaceMeshing_8hpp.html" title=" " alt="" coords="603,370,864,397"/>
<area shape="rect" href="tetMaker_8hpp_source.html" title=" " alt="" coords="2433,273,2572,315"/>
<area shape="rect" title=" " alt="" coords="3362,459,3422,486"/>
<area shape="rect" href="RTree_8hpp_source.html" title=" " alt="" coords="3784,281,3904,307"/>
<area shape="rect" href="box_8hpp_source.html" title=" " alt="" coords="686,281,794,307"/>
<area shape="rect" href="getElemInfo_8hpp_source.html" title=" " alt="" coords="652,459,815,486"/>
<area shape="rect" title=" " alt="" coords="1676,370,1756,397"/>
<area shape="rect" title=" " alt="" coords="1780,363,1927,404"/>
<area shape="rect" title=" " alt="" coords="1951,363,2092,404"/>
<area shape="rect" title=" " alt="" coords="1093,459,1275,486"/>
<area shape="rect" title=" " alt="" coords="2116,370,2233,397"/>
<area shape="rect" title=" " alt="" coords="2257,370,2436,397"/>
<area shape="rect" title=" " alt="" coords="2461,370,2545,397"/>
<area shape="rect" title=" " alt="" coords="2569,370,2695,397"/>
<area shape="rect" title=" " alt="" coords="2719,370,2844,397"/>
<area shape="rect" title=" " alt="" coords="2869,370,2979,397"/>
<area shape="rect" title=" " alt="" coords="3004,370,3119,397"/>
<area shape="rect" title=" " alt="" coords="3143,370,3209,397"/>
<area shape="rect" title=" " alt="" coords="3233,370,3308,397"/>
<area shape="rect" title=" " alt="" coords="3332,370,3423,397"/>
<area shape="rect" href="libmeshConversions_8hpp_source.html" title=" " alt="" coords="1385,370,1601,397"/>
<area shape="rect" title=" " alt="" coords="1452,459,1631,486"/>
<area shape="rect" title=" " alt="" coords="1655,452,1822,493"/>
<area shape="rect" title=" " alt="" coords="1846,459,2007,486"/>
<area shape="rect" title=" " alt="" coords="2031,459,2222,486"/>
<area shape="rect" title=" " alt="" coords="2247,452,2465,493"/>
<area shape="rect" title=" " alt="" coords="2489,452,2668,493"/>
<area shape="rect" title=" " alt="" coords="2693,452,2865,493"/>
<area shape="rect" title=" " alt="" coords="2889,452,3097,493"/>
<area shape="rect" title=" " alt="" coords="3121,459,3287,486"/>
<area shape="rect" title=" " alt="" coords="3856,370,3923,397"/>
<area shape="rect" title=" " alt="" coords="3947,370,4015,397"/>
<area shape="rect" title=" " alt="" coords="4040,370,4115,397"/>
<area shape="rect" title=" " alt="" coords="4139,370,4210,397"/>
<area shape="rect" title=" " alt="" coords="3548,370,3633,397"/>
<area shape="rect" title=" " alt="" coords="3658,370,3745,397"/>
<area shape="rect" title=" " alt="" coords="3769,370,3831,397"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb075efa4d0d8c61ac7e8148bc9c4e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#afb075efa4d0d8c61ac7e8148bc9c4e82">generateCoilBoundary</a> (libMesh::Mesh &amp;mesh, Eigen::MatrixXd &amp;boundVerts, Eigen::MatrixXi &amp;boundElems, double length, int subdivisions, std::string triSettings)</td></tr>
<tr class="separator:afb075efa4d0d8c61ac7e8148bc9c4e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387f1e15b0edd58aa1d3a9f5181c4272"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a387f1e15b0edd58aa1d3a9f5181c4272">calculateLocalCoords</a> (Eigen::Vector3d &amp;point, Eigen::Vector3d newOrigin, Eigen::Matrix3d newBasis, Eigen::Vector3d oldOrigin, Eigen::Matrix3d oldBasis)</td></tr>
<tr class="separator:a387f1e15b0edd58aa1d3a9f5181c4272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232e0bb76e764b5aa7c2faff8fa8553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a0232e0bb76e764b5aa7c2faff8fa8553">changeMeshBasis</a> (libMesh::Mesh &amp;mesh, Eigen::Vector3d newOrigin, Eigen::Matrix3d newBasis, Eigen::Vector3d oldOrigin, Eigen::Matrix3d oldBasis)</td></tr>
<tr class="separator:a0232e0bb76e764b5aa7c2faff8fa8553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a055d2db855f4634845b9e468a26ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a0a055d2db855f4634845b9e468a26ff9">changeMeshBasis</a> (Eigen::MatrixXd &amp;V, Eigen::Vector3d newOrigin, Eigen::Matrix3d newBasis, Eigen::Vector3d oldOrigin, Eigen::Matrix3d oldBasis)</td></tr>
<tr class="separator:a0a055d2db855f4634845b9e468a26ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0586d301ee40a2779037221965e9a1"><td class="memItemLeft" align="right" valign="top"><a id="a2f0586d301ee40a2779037221965e9a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>translateMesh</b> (Eigen::MatrixXd &amp;V, Eigen::Vector3d translationVector)</td></tr>
<tr class="separator:a2f0586d301ee40a2779037221965e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5d781a36fa38b5a4cd85340f73be6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#ada5d781a36fa38b5a4cd85340f73be6d">getBasisMatrix</a> (Eigen::Matrix3d &amp;basisMatrix, Eigen::Matrix3d &amp;planePoints)</td></tr>
<tr class="separator:ada5d781a36fa38b5a4cd85340f73be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7abb9d38f68793ff2e0d21c4dd955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#ae9c7abb9d38f68793ff2e0d21c4dd955">generateCoilFaceBound</a> (Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXd &amp;holes, Eigen::MatrixXd &amp;triV, Eigen::MatrixXi &amp;triF, double length, int subdivisions, std::string triSettings, libMesh::Mesh &amp;test)</td></tr>
<tr class="separator:ae9c7abb9d38f68793ff2e0d21c4dd955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c0eab78d5a68122dcdf3380fde2882"><td class="memItemLeft" align="right" valign="top"><a id="a54c0eab78d5a68122dcdf3380fde2882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>generateCoilFaceBound</b> (libMesh::Mesh &amp;mesh, libMesh::Mesh &amp;outputMesh, libMesh::Mesh &amp;remainingBoundary, Eigen::MatrixXd &amp;holes, double maxElemSize)</td></tr>
<tr class="separator:a54c0eab78d5a68122dcdf3380fde2882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f80a6b39971c62e50b5a14df38f81"><td class="memItemLeft" align="right" valign="top"><a id="adc3f80a6b39971c62e50b5a14df38f81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>genSidesetMesh</b> (libMesh::Mesh &amp;mesh, libMesh::Mesh &amp;sidesetMesh, std::vector&lt; std::string &gt; ssNames)</td></tr>
<tr class="separator:adc3f80a6b39971c62e50b5a14df38f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a839f90da5eda4f06dcc9e1bbb2ef7"><td class="memItemLeft" align="right" valign="top"><a id="a23a839f90da5eda4f06dcc9e1bbb2ef7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>genSidesetBounds</b> (Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, double length, int subdivisions)</td></tr>
<tr class="separator:a23a839f90da5eda4f06dcc9e1bbb2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39157ee0bc87a1082b798aa83827bb2"><td class="memItemLeft" align="right" valign="top"><a id="ae39157ee0bc87a1082b798aa83827bb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>genSidesetBounds</b> (libMesh::Mesh &amp;sidesetMesh, libMesh::Mesh &amp;remainingBoundary)</td></tr>
<tr class="separator:ae39157ee0bc87a1082b798aa83827bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3de388dd5efaebd4595f98be272bbcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#aa3de388dd5efaebd4595f98be272bbcb">getCoplanarSeedPoints</a> (libMesh::Mesh &amp;mesh, Eigen::MatrixXd &amp;seedPoints, std::string ss1Name, std::string ss2Name)</td></tr>
<tr class="separator:aa3de388dd5efaebd4595f98be272bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606a8b9633873f5d3573210829bdc579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a606a8b9633873f5d3573210829bdc579">genSquare</a> (Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, double length, int subdivisions)</td></tr>
<tr class="separator:a606a8b9633873f5d3573210829bdc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991d360423f4992ead1aa1c93740c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a7991d360423f4992ead1aa1c93740c8e">combineIGLMeshes</a> (Eigen::MatrixXd &amp;V1, Eigen::MatrixXi &amp;F1, Eigen::MatrixXd &amp;V2, Eigen::MatrixXi &amp;F2)</td></tr>
<tr class="separator:a7991d360423f4992ead1aa1c93740c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ea05803893ed967b568927ae369c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boundaryGeneration_8cpp.html#a00ea05803893ed967b568927ae369c37">genRemainingBoundary</a> (Eigen::MatrixXd &amp;vTri, Eigen::MatrixXi &amp;fTri, double length, int subdivisions, std::string triSettings, double tol)</td></tr>
<tr class="separator:a00ea05803893ed967b568927ae369c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a387f1e15b0edd58aa1d3a9f5181c4272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387f1e15b0edd58aa1d3a9f5181c4272">&#9670;&nbsp;</a></span>calculateLocalCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d calculateLocalCoords </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>newOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>newBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>oldOrigin</em> = <code>{0,&#160;0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>oldBasis</em> = <code>Eigen::Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method that calculates the coordinates of a set of coordinates in a new basis. The default arguments assume that you are moving your point from the "standard" cartesian space (origin = 0,0,0 x_basis = 1, 0, 0 etc.) </p>

</div>
</div>
<a id="a0a055d2db855f4634845b9e468a26ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a055d2db855f4634845b9e468a26ff9">&#9670;&nbsp;</a></span>changeMeshBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void changeMeshBasis </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>newOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>newBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>oldOrigin</em> = <code>{0,&#160;0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>oldBasis</em> = <code>Eigen::Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate/translate a mesh according to a set of new basis vectors, and a new origin. Function overload for use with libIGL (Eigen) meshes </p>

</div>
</div>
<a id="a0232e0bb76e764b5aa7c2faff8fa8553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0232e0bb76e764b5aa7c2faff8fa8553">&#9670;&nbsp;</a></span>changeMeshBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void changeMeshBasis </td>
          <td>(</td>
          <td class="paramtype">libMesh::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>newOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>newBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>oldOrigin</em> = <code>{0,&#160;0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d&#160;</td>
          <td class="paramname"><em>oldBasis</em> = <code>Eigen::Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate/translate a mesh according to a set of new basis vectors, and a new origin. </p>

</div>
</div>
<a id="a7991d360423f4992ead1aa1c93740c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7991d360423f4992ead1aa1c93740c8e">&#9670;&nbsp;</a></span>combineIGLMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void combineIGLMeshes </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for combining two libigl meshes that you are SURE do NOT intersect/ have duplicate nodes. There is a combine meshes method in removeDupeNodes.cpp that can combine meshes with duplicate nodes using an rTree data structure, so if you need that, use that. Here V1 and F1 are the vertice and element data structures for the first mesh, and V2 and F2 represent the second mesh. The meshes will be merged into the first mesh (V1, F1) </p>

</div>
</div>
<a id="afb075efa4d0d8c61ac7e8148bc9c4e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb075efa4d0d8c61ac7e8148bc9c4e82">&#9670;&nbsp;</a></span>generateCoilBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateCoilBoundary </td>
          <td>(</td>
          <td class="paramtype">libMesh::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>boundVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>boundElems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>triSettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to generate the boundary for a coil. A method exists specifically for coils, as often the boundary needs to be coplanar with some coil "in" and "out" sidesets. This method will generate the correct boundary for a problem of this nature. The method takes in your starting mesh "mesh", two Eigen objects "boundVerts" and "boundElems" that represent the output boundary vertices and faces (vertice connectivity data) </p>

</div>
</div>
<a id="ae9c7abb9d38f68793ff2e0d21c4dd955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7abb9d38f68793ff2e0d21c4dd955">&#9670;&nbsp;</a></span>generateCoilFaceBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateCoilFaceBound </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>holes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>triV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>triF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tri_settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libMesh::Mesh &amp;&#160;</td>
          <td class="paramname"><em>test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for generating the face of the cubic boundary that is coplanar with the coil sidesets. Here V and F are the vertices and faces(connectivity data) for the input mesh, which is probably composed of 2D edge elements. holes is a matric which contains any seeding points used for the triangulation of the closed space described by V and F. triV and triF are the data structures where the data for the output tri mesh will be stored. </p>

</div>
</div>
<a id="a00ea05803893ed967b568927ae369c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ea05803893ed967b568927ae369c37">&#9670;&nbsp;</a></span>genRemainingBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void genRemainingBoundary </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>fTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>triSettings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates the 5 remaining faces of a cubic boundary </p>

</div>
</div>
<a id="a606a8b9633873f5d3573210829bdc579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606a8b9633873f5d3573210829bdc579">&#9670;&nbsp;</a></span>genSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void genSquare </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdivisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method generates a square boundary comprised of just edge elements. The verts argument will be populated with the vertex data, elems will be populated with the element connectivity data and length and subdivisions allow the user to change the length of the edges of the square, as well as how many elements there should be per "edge" </p>

</div>
</div>
<a id="ada5d781a36fa38b5a4cd85340f73be6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5d781a36fa38b5a4cd85340f73be6d">&#9670;&nbsp;</a></span>getBasisMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getBasisMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>basisMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>planePoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method takes in an Eigen::Matrix "basisMatrix" by reference. This matrix will be populated with the basis vectors for a cartesian coordinate system. The new systems "XY" plane is defined by 3 points contained within "planePoints". I need to add a check in that makes sure these 3 points are not on the same line, and hence properly define a plane. This makes this new plane the Z=0 point of the new system. "basisMatrix" is population with the basis vectors for the new system, organised by column (x basis = column 1 etc.) </p>

</div>
</div>
<a id="aa3de388dd5efaebd4595f98be272bbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3de388dd5efaebd4595f98be272bbcb">&#9670;&nbsp;</a></span>getCoplanarSeedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getCoplanarSeedPoints </td>
          <td>(</td>
          <td class="paramtype">libMesh::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>seedPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ss1Name</em> = <code>&quot;coil_in&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ss2Name</em> = <code>&quot;coil_out&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For our coil problem, to generate the part of the boundary that is coplanar with the coil sidesets correctly </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
